<!doctype html public "-//W3C//DTD HTML 4.0 Transitional //EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset-us-ascii">
  <style>

body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  /* overflow: hidden; */
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
  min-width: 200px;
  max-width: 790px;
  margin: 0 auto;
  padding: 30px;
}

 a {
  background-color: transparent;
}

 a:active,
 a:hover {
  outline: 0;
}

 strong {
  font-weight: bold;
}

 h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

 img {
  border: 0;
}

 hr {
  box-sizing: content-box;
  height: 0;
}

 pre {
  overflow: auto;
}

 code,
 kbd,
 pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

 input {
  color: inherit;
  font: inherit;
  margin: 0;
}

 html input[disabled] {
  cursor: default;
}

 input {
  line-height: normal;
}

 input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

 table {
  border-collapse: collapse;
  border-spacing: 0;
}

 td,
 th {
  padding: 0;
}

 * {
  box-sizing: border-box;
}

 input {
  font: 13px/1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
}

 a {
  color: #4078c0;
  text-decoration: none;
}

 a:hover,
 a:active {
  text-decoration: underline;
}

 hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

 hr:before {
  display: table;
  content: "";
}

 hr:after {
  display: table;
  clear: both;
  content: "";
}

 h1,
 h2,
 h3,
 h4,
 h5,
 h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

 h1 {
  font-size: 30px;
}

 h2 {
  font-size: 21px;
}

 h3 {
  font-size: 16px;
}

 h4 {
  font-size: 14px;
}

 h5 {
  font-size: 12px;
}

 h6 {
  font-size: 11px;
}

 blockquote {
  margin: 0;
}

 ul,
 ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

 ol ol,
 ul ol {
  list-style-type: lower-roman;
}

 ul ul ol,
 ul ol ol,
 ol ul ol,
 ol ol ol {
  list-style-type: lower-alpha;
}

 dd {
  margin-left: 0;
}

 code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

 pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

 .select::-ms-expand {
  opacity: 0;
}

>*:first-child {
  margin-top: 0 !important;
}

>*:last-child {
  margin-bottom: 0 !important;
}

 a:not([href]) {
  color: inherit;
  text-decoration: none;
}

 .anchor {
  position: absolute;
  top: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

 .anchor:focus {
  outline: none;
}

 h1,
 h2,
 h3,
 h4,
 h5,
 h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

 h1:hover .anchor,
 h2:hover .anchor,
 h3:hover .anchor,
 h4:hover .anchor,
 h5:hover .anchor,
 h6:hover .anchor {
  padding-left: 8px;
  margin-left: -30px;
  text-decoration: none;
}

 h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

 h1 .anchor {
  line-height: 1;
}

 h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

 h2 .anchor {
  line-height: 1;
}

 h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

 h3 .anchor {
  line-height: 1.2;
}

 h4 {
  font-size: 1.25em;
}

 h4 .anchor {
  line-height: 1.2;
}

 h5 {
  font-size: 1em;
}

 h5 .anchor {
  line-height: 1.1;
}

 h6 {
  font-size: 1em;
  color: #777;
}

 h6 .anchor {
  line-height: 1.1;
}

 p,
 blockquote,
 ul,
 ol,
 dl,
 table,
 pre {
  margin-top: 0;
  margin-bottom: 16px;
}

 hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

 ul,
 ol {
  padding-left: 2em;
}

 ul ul,
 ul ol,
 ol ol,
 ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

 li>p {
  margin-top: 16px;
}

 dl {
  padding: 0;
}

 dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

 dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

 blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

 blockquote>:first-child {
  margin-top: 0;
}

 blockquote>:last-child {
  margin-bottom: 0;
}

 table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

 table th {
  font-weight: bold;
}

 table th,
 table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

 table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

 table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

 img {
  max-width: 100%;
  box-sizing: border-box;
}

 code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

 code:before,
 code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

 pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

 .highlight {
  margin-bottom: 16px;
}

 .highlight pre,
 pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

 .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

 pre {
  word-wrap: normal;
}

 pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

 pre code:before,
 pre code:after {
  content: normal;
}

 kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

 .pl-c {
  color: #969896;
}

 .pl-c1,
 .pl-s .pl-v {
  color: #0086b3;
}

 .pl-e,
 .pl-en {
  color: #795da3;
}

 .pl-s .pl-s1,
 .pl-smi {
  color: #333;
}

 .pl-ent {
  color: #63a35c;
}

 .pl-k {
  color: #a71d5d;
}

 .pl-pds,
 .pl-s,
 .pl-s .pl-pse .pl-s1,
 .pl-sr,
 .pl-sr .pl-cce,
 .pl-sr .pl-sra,
 .pl-sr .pl-sre {
  color: #183691;
}

 .pl-v {
  color: #ed6a43;
}

 .pl-id {
  color: #b52a1d;
}

 .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

 .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

 .pl-ml {
  color: #693a17;
}

 .pl-mh,
 .pl-mh .pl-en,
 .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

 .pl-mq {
  color: #008080;
}

 .pl-mi {
  color: #333;
  font-style: italic;
}

 .pl-mb {
  color: #333;
  font-weight: bold;
}

 .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

 .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

 .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

 .pl-mo {
  color: #1d3e81;
}

 kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

 .task-list-item {
  list-style-type: none;
}

 .task-list-item+.task-list-item {
  margin-top: 3px;
}

 .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

 :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}
  </style>
</head>
<body>
    <h1>OCaml Towards Clarity and Grace</h1>
    <ul>
 <li><a href="#OCaml.Towards.Clarity.and.Grace">OCaml Towards Clarity and Grace</a>
 <ul>
  <li><a href="#Other.Resources">Other Resources</a></li>
  <li><a href="#Indentation..Line.Length">Indentation, Line Length</a></li>
  <li><a href="#Comments">Comments</a>
  <ul>
   <li><a href="#What.to.Comment">What to Comment</a></li>
   <li><a href="#What.not.to.Comment">What not to Comment</a></li>
   <li><a href="#Examples">Examples</a></li>
   <li><a href="#Caveats">Caveats</a></li>
   <li><a href="#Viewing.rendered.documentation">Viewing rendered documentation</a></li>
  </ul>
  </li>
  <li><a href="#Naming.and.Declarations">Naming and Declarations</a></li>
  <li><a href="#Scoping">Scoping</a></li>
  <li><a href="#Constants">Constants</a></li>
  <li><a href="#Introduce.and.Document.Interfaces">Introduce and Document Interfaces</a></li>
  <li><a href="#Avoid.Opening.Modules.Globally">Avoid Opening Modules Globally</a>
  <ul>
   <li><a href="#Do.This.Instead">Do This Instead</a></li>
   <li><a href="#Rationale">Rationale</a></li>
  </ul>
  </li>
  <li><a href="#Avoid.using.references">Avoid using references</a></li>
  <li><a href="#Equality:..code.....code..and..code.....code..vs..code..lt..gt...code..and..code....code.">Equality: <code>!=</code> and <code>==</code> vs <code>&lt;&gt;</code> and <code>=</code></a></li>
  <li><a href="#if.vs..match.-.use.of.semicolon">if vs. match - use of semicolon</a></li>
  <li><a href="#Error.Messages.and.Error.Handling">Error Messages and Error Handling</a></li>
  <li><a href="#Split.imperative.and.functional.code">Split imperative and functional code</a></li>
  <li><a href="#Functions.-.Argument.Order">Functions - Argument Order</a></li>
  <li><a href="#Functions.-.Pattern.Matching">Functions - Pattern Matching</a></li>
  <li><a href="#Functions.-.Data.Flow">Functions - Data Flow</a></li>
  <li><a href="#Functions.-.Avoid.Deep.Nesting">Functions - Avoid Deep Nesting</a></li>
  <li><a href="#Functions.-.Tail.Recursion">Functions - Tail Recursion</a></li>
  <li><a href="#Resources.and.Exceptions:.use.finally">Resources and Exceptions: use finally</a></li>
  <li><a href="#Compare.Functions">Compare Functions</a></li>
  <li><a href="#Git.-.Commit.Messages">Git - Commit Messages</a></li>
  <li><a href="#Use.Pattern.Matching.for.Value.Destruction">Use Pattern Matching for Value Destruction</a></li>
  <li><a href="#Avoid.introducing.new.dependencies">Avoid introducing new dependencies</a></li>
 </ul>
 </li>
</ul>

    <h1 id="OCaml.Towards.Clarity.and.Grace">OCaml Towards Clarity and Grace</h1>

<p>This is a guide towards writing better <a href="https://www.ocaml.org/">OCaml</a> code.  We all like to
write <a href="https://www.ocaml.org/">OCaml</a> code that is correct, maintainable, efficient, and maybe
even beautiful. The sad truth is that this cannot be achieved simply by
following some rules. Just like it is not enough for a book to be
composed of correct sentences and coherent paragraphs. However, a book
violating these principles stands little chance of finding many readers.
Likewise, this guide tries to help with the small structures in
programming <a href="https://www.ocaml.org/">OCaml</a> upon which we can hope to build bigger ones.</p>

<p>File <a href="README.html">README.html</a> is a self-contained HTML page of this
document and includes a table of contents.</p>

<h2 id="Other.Resources">Other Resources</h2>

<ul>
<li><a href="https://www.seas.upenn.edu/~cis341/current/programming_style.shtml">Upenn</a>&rsquo;s style guide for student projects</li>
<li><a href="https://ocaml.org/learn/tutorials/guidelines.html">OCaml Tutorial</a></li>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">OCaml Manual</a></li>
<li><a href="https://realworldocaml.org/">Real World OCaml</a> Book</li>
</ul>


<h2 id="Indentation..Line.Length">Indentation, Line Length</h2>

<ul>
<li><p>Indentation must always reflect the logic of a program.</p></li>
<li><p>In existing code, adopt the existing style for indentation: tabs or
spaces.</p></li>
<li><p>Line length should not exceed 100 characters. Break up long lines in
new code in particular.</p></li>
<li><p>For new code, prefer spaces over tabs and use <a href="https://github.com/OCamlPro/ocp-indent">ocp-indent</a> to maintain
consistent indentation. Note that <a href="https://github.com/OCamlPro/ocp-indent">ocp-indent</a> does not break up long lines.</p></li>
<li><p>Most OCaml code bases uses 2 spaces per indentation level.</p></li>
<li><p>When making changes ensure that indentation is still correct after your change,
re-indenting as necessary, but not excessively</p></li>
</ul>


<p>Rationale:</p>

<ul>
<li>Overly long lines create problems when printing source code and when
resolving merge conflicts in tools by forcing a lot of sideways
scrolling.</li>
<li>Spaces are unambiguous in meaning whereas tabs depend on the
environment.</li>
<li><a href="https://github.com/OCamlPro/ocp-indent">ocp-indent</a> is a proven way to re-establish consistent
indentation while still leaving room for other aspects of code
formatting.</li>
<li>When adding an &lsquo;if&rsquo; expression it might be necessary to reindent the whole body of a function,
but avoid re-indenting the whole file, which causes merge conflicts with people working on
other branches, it is best to plan ahead and do such large scale changes as separate commits.</li>
</ul>


<h2 id="Comments">Comments</h2>

<p>Comments generally go before the code they are referencing. The possible
exception are declarations in interfaces (mli files, signatures) and
types where they can go after the declaration.</p>

<p>Syntactically there are two kinds of comments:</p>

<ol>
<li>General comments, enclosed in <code>(*</code> and <code>*)</code></li>
<li>Special comments, enclosed in <code>(**</code> and <code>*)</code></li>
</ol>


<p>Special comments are associated with type and values in a program and
treated specially by the compiler. They become available in automatically
generated documentation.  For the association to work, there must be no
empty line between a special comment and the element they are associated
with. See the section about <a href="http://caml.inria.fr/pub/docs/manual-ocaml/ocamldoc.html">ocamldoc</a> for details.</p>

<p>Code should always be as clear as possible but that clarity cannot
always convey the reason behind a design. Comments have the role to
provide it: the why.</p>

<h3 id="What.to.Comment">What to Comment</h3>

<ul>
<li>The purpose of a module or functor</li>
<li>The purpose of a value or function in a signature (interface)</li>
<li>The purpose of a type declaration or its components, if not obvious</li>
<li>The purpose of record components and variants in types, if not obvious</li>
<li>Unusual Algorithms and their complexity</li>
<li>Invariants when not expressed as assertions</li>
<li>Error handling</li>
<li>Basic examples on how to use the library</li>
<li>Known limitations</li>
<li>Short introduction to the technology covered by the library, if not obvious</li>
</ul>


<h3 id="What.not.to.Comment">What not to Comment</h3>

<ul>
<li>Purpose of a local let binding - the name should tell it</li>
<li>Every line in function</li>
</ul>


<h3 id="Examples">Examples</h3>

<ul>
<li><p><a href="https://github.com/ocaml/ocaml/blob/trunk/stdlib/list.mli">Ocaml List</a>
The documentation of the standard list module. Each function is
commented below its signature.</p></li>
<li><p><a href="https://github.com/c-cube/ocaml-containers/blob/master/src/data/CCHashSet.mli">Container Hash Set</a></p></li>
<li><p><a href="https://github.com/dbuenzli/mtime/blob/master/src/mtime.mli">Mtime</a>
with <a href="https://github.com/dbuenzli/mtime/blob/master/src/mtime.ml">implementation</a>
and <a href="http://erratique.ch/software/mtime/doc/Mtime">rendered documentation</a></p></li>
<li><p><a href="https://github.com/dbuenzli/uunf/blob/master/src/uunf.mli">Uunf</a>
with <a href="https://github.com/dbuenzli/uunf/blob/master/src/uunf.ml">implementation</a> and
<a href="http://erratique.ch/software/uunf/doc/Uunf">rendered documentation</a></p></li>
<li><p>Introduction to the domain covered by the library, e.g. introduction to unicode in <a href="http://erratique.ch/software/uucp/doc/Uucp.html">Uucp</a></p></li>
<li><p>Documentation stored together with code: squeezed <a href="https://github.com/xapi-project/squeezed/tree/master/doc/design">design</a> and <a href="https://github.com/xapi-project/squeezed/blob/169e2e3004082a129b95ed6184a0ab04d20b7f28/lib/memory.ml#L91-L117">diagrams</a></p></li>
</ul>


<h3 id="Caveats">Caveats</h3>

<p>Code duplication is bad but copying comments is worse. Be very careful
when copying comments to make sure they are not becoming misleading in a
new context.</p>

<h3 id="Viewing.rendered.documentation">Viewing rendered documentation</h3>

<p>You can use <code>odig odoc &amp;&amp; odig doc</code> to view the documentation of all installed packages.
If your package uses jbuilder then you can also view the documentation of
the package you are working on with <code>jbuilder doc</code>.</p>

<h2 id="Naming.and.Declarations">Naming and Declarations</h2>

<p><a href="https://www.ocaml.org/">OCaml</a> has a few conventions for names. In particular, capitalisation
is significant.</p>

<ul>
<li>Types: <code>lower_case</code>.</li>
<li>Type variables: <code>'lower_case</code></li>
<li>Values and Functions: <code>lower_case</code></li>
<li>Constructors: <code>UpperCase</code> or <code>Upper_Case</code></li>
<li>Record Fields: <code>lower_case</code></li>
<li>Modules: <code>UpperCase</code></li>
<li>Signatures: <code>UpperCase</code></li>
<li>Module Types: <code>ALLCAPS</code></li>
</ul>


<p>General considerations:</p>

<ul>
<li>Local names can be short, type variables very short.</li>
<li>Prefer short, but self-describing names in public interfaces</li>
<li>Use scoping (let, modules) to keep the number of names in a scope small.</li>
<li>Avoid encoding the type into a name: <code>x_int</code> or <code>x_opt</code> is usually not
better than <code>x</code>.</li>
<li>In a functional language like <a href="https://www.ocaml.org/">OCaml</a>, using <code>get</code> as part of a name
is often redundant unless it involves obtaining a value from a database
or file.</li>
<li>You may see auto-generated code use the style <code>.mIX_case</code> where <code>.MIX_case</code> was meant,
but record fields cannot start with capital letters.
Avoid this in code your write.</li>
<li>You can use longer names for type variables if it improves clarity, e.g. for phantom types</li>
</ul>


<p>Order of declarations: in a module, typically the following order is
maintained unless dependencies force a different order or mixing
declarations:</p>

<ol>
<li>Exceptions</li>
<li>Types</li>
<li>Modules</li>
<li>Values</li>
</ol>


<p>Special cases:</p>

<ul>
<li><p>A file <code>abc.ml</code> is mapped to module <code>Abc</code> even though the filename is
not capitalised. The corresponding interface is <code>abc.mli</code>.</p></li>
<li><p>When a module defines a central (often abstract) data type, it is
typically named <code>t</code>:</p></li>
</ul>


<pre><code>module Tree: sig
  type 'a t
  val empty: 'a t
end = struct
  type 'a t = Empty | Tree of 'a t * 'a * 'a t
  let empty = Empty
end
</code></pre>

<h2 id="Scoping">Scoping</h2>

<p>Use the module system to group values. It&rsquo;s quite common to define
simple values that belong together and to indicate this in their names:</p>

<pre><code>let option_debug     = false
let option_verbosity = High
let option_log       = stdout
</code></pre>

<p>It is better to let the module system do the work:</p>

<pre><code>module Option = struct
  let debug     = false
  let verbosity = High
  let log       = stdout
end
</code></pre>

<p>A value can now be accessed like in <code>Option.debug</code>. A module simply used
for grouping doesn&rsquo;t require an interface.</p>

<h2 id="Constants">Constants</h2>

<ul>
<li>Avoid using magic constants as literals like <code>86400</code> for the number of
seconds in a day. Constants should be let-bound to a name:</li>
</ul>


<pre><code>let ( ** ) x y    = Int64.mul (Int64.of_int x) y
let sec           = 1L
let sec_per_min   = 60 ** sec
let sec_per_hour  = 60 ** sec_per_min
let sec_per_day   = 24 ** sec_per_hour
</code></pre>

<ul>
<li><p>For literals, picking the correct base can make them less magical:
compare <code>255</code> (decimal) with <code>0xff</code> (hexadecimal) or <code>0b111_1111</code>
(binary).</p></li>
<li><p>Structure long literal numbers with underscores for
readability as in <code>0b1111_1111</code> above. It works in all bases, like for
example in <code>1_000_000</code>.</p></li>
</ul>


<p>More details are in the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/lex.html">Ocaml Manual</a>.</p>

<h2 id="Introduce.and.Document.Interfaces">Introduce and Document Interfaces</h2>

<p>Module interfaces are the best way to document and control an
implementation - employ them widely.</p>

<p>A module encapsulates code serving a specific purpose. An interface
should hide implementation details and document the API.</p>

<p>In <a href="https://www.ocaml.org/">OCaml</a>, every file <code>abc.ml</code> is a module and should come with an
interface <code>abc.mli</code>. In addition, a module can be part of a (file)
module using <code>struct .. end</code>. This is the only way to define functors.</p>

<pre><code>module ID : sig
  type t

  val make: unit -&gt; t
  (** [make] creates a unique token *)

  val equal: t -&gt; t -&gt; bool
  (** [equal] is true, if and only if two tokens are the same *)
end = struct
  type t = unit ref
  let make () = ref ()
  let equal x y = x == y (* use pointer equality *)
end
</code></pre>

<ul>
<li>Add list of examples here</li>
</ul>


<p>Interfaces not only help document code, but can also prevent needless recompilation
(at least when you are using bytecode).
As an exception to this rule, if your module only defines signatures then prefer using
a <code>.ml</code> file for this, otherwise either the <code>.mli</code> would just be a duplicate of the <code>.ml</code> file,
or you&rsquo;d have to use <code>.mli</code>-only modules which don&rsquo;t have good tooling support.</p>

<h2 id="Avoid.Opening.Modules.Globally">Avoid Opening Modules Globally</h2>

<p>For convenience, many developers open modules globally in order to gain
access to functions without having to use qualified access. Below,
<code>Printf</code>, <code>List</code>, and <code>Sys</code> are opened in this way:</p>

<pre><code>open Printf
open List
open Sys

let rec join = function
  | []      -&gt; ""
  | [x]     -&gt; x
  | [x;y]   -&gt; x ^ " and " ^ y
  | x::xs   -&gt; x ^ ", "    ^ join xs

let main () =
  let argv = Array.to_list argv in
  let args = tl argv in
  match args with
  | []        -&gt; printf "Hello, world!\n"
  | names     -&gt; printf "Hello, %s!\n" (join names)

let () = main ()
</code></pre>

<h3 id="Do.This.Instead">Do This Instead</h3>

<p>Between opening a module globally and not at all, several options exist.</p>

<ul>
<li><p>Always use fully qualified names (see the code below). This is the
best solution if we need few values from a module and only
sporadically.</p>

<pre><code>let main () =
  let argv = Array.to_list Sys.argv in
  let args = List.tl argv in
  match args with
  | []        -&gt; Printf.printf "Hello, world!\n"
  | names     -&gt; Printf.printf "Hello, %s!\n" (join names)
</code></pre></li>
<li><p>Introduce aliases to shorten long module and function names. This is
almost always a good solution.</p>

<pre><code>module L = List

let printf  = Printf.printf
let sprintf = Printf.sprintf
</code></pre></li>
<li><p>Open a module locally with open</p>

<p>Opening a module locally limits the scope for the open module:</p>

<pre><code>let main () =
  let open Printf in
  let argv = Array.to_list Sys.argv in
  let args = List.tl argv in
  match args with
  | []        -&gt; printf "Hello, world!\n"
  | names     -&gt; printf "Hello, %s!\n" (join names)
</code></pre></li>
<li><p>Open a module locally with Module.()</p>

<pre><code>Int64.(add (of_int x) 1_000_000L)
</code></pre>

<p>The code above is another way of writing the code below. The module
<code>Int64</code> is open inside the parentheses.</p>

<pre><code>Int64.add (Int64.of_int x) 1_000_000L
</code></pre>

<p>This is especially effective to access constructors that are defined
inside a module</p></li>
<li><p>Define a sub-module that is meant to be opened (locally), to be used sparingly:</p>

<pre><code>module M = struct
   type +'a t
   module Infix = struct
     val (&gt;&gt;=) : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t
   end
   ...
end
....
let foo =
   let open M.Infix in
   f x
   &gt;&gt;= fun () -&gt;
   ...
</code></pre>

<p>This avoid bringing in all the names from <code>M</code> itself in scope,
it only brings in scope the very small number of operators defined by <code>M.Infix</code></p></li>
</ul>


<h3 id="Rationale">Rationale</h3>

<p>Opening a module introduces all its values and constructors into the
local module. Since the definitions of these values and constructors are
not visible, it becomes very hard to understand the code without tool
support. While a developer might argue that tool support is available,
it is not during reviews on GitHub or when looking at a printout. The
problem is exaggerated when several modules are opened.</p>

<h2 id="Avoid.using.references">Avoid using references</h2>

<p>Most code does not require references. Introducing them should be well
justified. In particular, using references to implement loops and
similar local control flow is probably avoidable.</p>

<h2 id="Equality:..code.....code..and..code.....code..vs..code..lt..gt...code..and..code....code.">Equality: <code>!=</code> and <code>==</code> vs <code>&lt;&gt;</code> and <code>=</code></h2>

<p>Using <code>!=</code> and <code>==</code> for equality is probably wrong and you should use
<code>&lt;&gt;</code> and <code>=</code> instead.</p>

<p><a href="https://www.ocaml.org/">OCaml</a> has two kinds of equality:</p>

<ol>
<li><p>Structural equality, tested with <code>=</code> and <code>&lt;&gt;</code>. This compares the
shape of two values and is typically the correct choice.</p></li>
<li><p>Physical equality (pointer equality), tested with <code>==</code> and <code>!=</code>. This compares the
address in memory of two values. This is typically used in
performance-oriented code. Pointer equality implies structural
equality but not vice versa.</p></li>
</ol>


<h2 id="if.vs..match.-.use.of.semicolon">if vs. match - use of semicolon</h2>

<p>Be aware that statement sequences require <code>begin</code>/<code>end</code> in <code>if</code>
expressions.  <a href="https://www.ocaml.org/">OCaml</a> has some inconsistencies how it handles statement
sequences (containing <code>;</code>). Compare:</p>

<pre><code>match true with
  | true -&gt; ()
  | false -&gt; print_endline "1"; print_endline "2"
(* prints nothing *)
</code></pre>

<p>versus:</p>

<pre><code>if false then print_endline "1"; print_endline "2"
(* prints 2 *)
</code></pre>

<p>A statement sequence inside an <code>if</code> or <code>else</code> branch must be grouped by
<code>begin</code>/<code>end</code> or parentheses to be governed by the guard.</p>

<pre><code>if false then begin
  print_endline "1";
  print_endline "2"
end else begin
  print_endline "3";
  print_endline "4"
end
</code></pre>

<p>The danger of not realising what code is governed by an if-expression is
exasperated by incorrect indentation and by incremental changes to
existing code.</p>

<h2 id="Error.Messages.and.Error.Handling">Error Messages and Error Handling</h2>

<ul>
<li><p>For handling errors programmatically, appropriate error values should
be defined to avoid matching against strings (The standard library is
violating this principle.)</p></li>
<li><p>Log messages are typically created from strings. <a href="https://www.ocaml.org/">OCaml</a> defines the
following strings to report the location of an error: <code>__LOC__</code>,
<code>__FILE__</code>, <code>__LINE__</code>, <code>__MODULE__</code> and a few more &ndash; see
<a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html">Ocaml Pervasives</a></p></li>
<li><p>Constructing log and error messages can be made simpler by defining a
function that behaves like <code>Printf.sprintf</code>:</p></li>
</ul>


<pre><code>type 'a t = Ok of 'a | Error of string
let error fmt = Printf.kprintf (fun msg -&gt; Error msg) fmt
</code></pre>

<ul>
<li><p>Messages going into a log still must make sense in the context of many
other lines before and after in the log. Therefore they must contain
enough detail.</p></li>
<li><p>Don&rsquo;t split log messages because in the actual log they be no longer
next to each other.</p></li>
</ul>


<h2 id="Split.imperative.and.functional.code">Split imperative and functional code</h2>

<p>Purely functional code is easiest to test. Therefore code should be as
functional as possible and imperative code minimised.</p>

<p>In order of preference the interface of a module should expose:
 * immutable data structures and operations on them</p>

<p>   Note that the implementation can use mutation if this makes the
   implementation of the algorithm more natural, as long as it doesn&rsquo;t
   &ldquo;leak&rdquo; the mutated variable by returning it or storing it outside local variables</p>

<ul>
<li>idempotent API calls</li>
</ul>


<p> If the nature of the API requires mutation (e.g. a database) make it idempotent.
 The reason is that network/RPC calls may get interrupted before getting an answer,
 and the caller may not know whether the call succeeded or not, so it can just retry.
 If you make the retry a no-op it simplifies the logic on both sides.</p>

<h2 id="Functions.-.Argument.Order">Functions - Argument Order</h2>

<p>In a function definition, the most common arguments should come first.</p>

<p>While a function can work with any order of formal arguments, putting
common arguments make it more usable.  For example:</p>

<pre><code>let sum     = List.fold_left (+) 0
let default x = function
  | None   -&gt; x
  | Some y -&gt; y

let sum' xs  = xs |&gt; List.map (default 0) |&gt; sum
</code></pre>

<p>Function <code>sum: int list -&gt; int</code> computes the sum from a list of
integers. It&rsquo;s definition is so concise because <code>List.fold_left</code> takes
its list argument last. Likewise, <code>default</code> and <code>List.map</code> combine well
because of the order of their arguments.
Usually operations on datastructures should always take the datastructure
last to allow for the above concise data-flow usage.</p>

<p>The best argument order is not always clear - so this should be just a
general consideration when writing code.</p>

<h2 id="Functions.-.Pattern.Matching">Functions - Pattern Matching</h2>

<p>Pattern matching is the preferred way to define functions. Patterns
are easier to read and extend than if-then-else expressions. Consider
matching multiple arguments at the same time to arrive at a short and
un-nested function definition.</p>

<p>The example below defines a binary tree and a function <code>sum</code> that sums
up the nodes along a path in the tree. It uses pattern matching
effectively by matching over two values (the current node, and the
current position in the path) at the same time.</p>

<pre><code>type 'a tree
  = Empty
  | Node of 'a tree * 'a * 'a tree

type branch = Left | Right
type path   = branch list

let sum tree path =
  let rec loop acc path tree = match path, tree with
    | []          , _           -&gt; acc
    | _::_        , Empty       -&gt; failwith "path too long"
    | Left::path  , Node(l,n,r) -&gt; loop (acc+n) path l
    | Right::path , Node(l,n,r) -&gt; loop (acc+n) path r
  in
    loop 0 path tree
</code></pre>

<h2 id="Functions.-.Data.Flow">Functions - Data Flow</h2>

<p>The readability of code can often be improved by using the pipe operator
<code>|&gt;</code> because it allows functions to be written such that data flows from
top to bottom and left to right.</p>

<p>Consider the following function <code>numbers</code> and <code>numbers'</code> that compute a
string from a list of optional numbers:</p>

<pre><code>let xs = [Some 1; None; Some 2; None; None; Some 3; Some 4; Some 5] in

let (++) x xs = match x with
  | Some x -&gt; x :: xs
  | None   -&gt; xs

let numbers xs =
  String.concat "," (List.map string_of_int (List.fold_right (++) xs [])

let numbers' xs =
  List.fold_right (++) xs []
  |&gt; List.map string_of_int
  |&gt; String.concat ", " ```
</code></pre>

<p>The definition of <code>numbers</code> is more traditional and <code>numbers'</code> uses the
pipe operator. In the latter the data from the argument <code>xs</code> flows
through the function definition from top to bottom and left to right.
In the more traditional definition, data flows from right to left.</p>

<h2 id="Functions.-.Avoid.Deep.Nesting">Functions - Avoid Deep Nesting</h2>

<p>Code that is deeply nested is hard to read and hard to test. This
suggests that it should be restructured - probably by introducing new
functions. Pattern matching is a another proven way to reduce the
nesting of code.</p>

<h2 id="Functions.-.Tail.Recursion">Functions - Tail Recursion</h2>

<p>Recursive functions operating on large data structures need to be tail
recursive as otherwise the runtime stack may overflow.</p>

<p>While tail recursiveness is generally desirable, it is often not
required because data is not large. For performance it is usually better
to pay attention to allocation patterns than to tail recursion.</p>

<p>Be aware that tail recursion can be inhibited by exceptions: the <code>loop</code>
below is not tail recursive!</p>

<pre><code>let read_lines inc =
   let rec loop acc =
     try
       let l = input_line inc in
       loop (l :: acc)
     with End_of_file -&gt; List.rev acc
   in
   loop []
</code></pre>

<p>To make it tail recursive, handling of values and exceptions need to be
combined into one <code>match</code> expression (available since OCaml 4.02):</p>

<pre><code>let read_lines io =
  let rec loop acc =
      match input_line io with
      | l -&gt; loop (l :: acc)
      | exception End_of_file -&gt; List.rev acc
  in
  loop []
</code></pre>

<p>Function calls can be annotated to receive a compiler warning if a call
is not tail recursive as expected:</p>

<pre><code>let read_lines io =
  let rec loop acc =
    try
      let l = input_line io in
      (loop [@tailcall]) (l :: acc)
    with End_of_file -&gt; List.rev acc
  in
  loop []
</code></pre>

<p>The problem with this is that one has to be aware of the problem in the
first place to write such an annotation.</p>

<p>Be aware that some functions from the standard library are not tail recursive (e.g. <code>List.map</code>).</p>

<h2 id="Resources.and.Exceptions:.use.finally">Resources and Exceptions: use finally</h2>

<p>Ensure that resources are de-allocated in the presence of exceptions.
This is typically done with a function like <code>finally</code>:</p>

<pre><code>let finally (f: unit -&gt; 'a) (free: unit -&gt; 'b) =
  let res = try f () with exn -&gt; free (); raise exn in
  free ();
  res

let with_file path (f: in_channel -&gt; 'a) =
  let io = open_in path in
  finally
    (fun () -&gt; f io)
    (fun () -&gt; close_in io)

with_file "/etc/passwd" (fun io -&gt; input_line io |&gt; print_endline)
</code></pre>

<p>In the above code we make sure to close the file even if the function
reading from it throws an exception. A function like <code>finally</code> should be
already defined in existing projects so there is no need to re-implement
it locally.</p>

<p>Resources that need to be managed are not just files but can be
anything like database and network connections or timers.</p>

<p>A more finer detail is that care should be taken not to destroy the backtrace
of an exception if the code in finally (or functions called by it)
raise/catch exceptions of its own.</p>

<h2 id="Compare.Functions">Compare Functions</h2>

<p><a href="https://www.ocaml.org/">OCaml</a> provides a generic [compare] function but it can give unexpected
results when comparing complex values or not a desired order. This is
the reason that the [Map.Make] functor requires to define a compare
function.  Here is a recipe to define a custom compare function:</p>

<pre><code>module Time = struct
  type 'a t =
    { hour:     int
    ; minutes:  int
    ; seconds:  int
    ; info:     'a
    }

  let (&lt;?&gt;) c (cmp,x,y) =
    if c = 0
    then cmp x y
    else c

  let compare t1 t2 =
    compare t1.hour t2.hour
    &lt;?&gt; (compare, t1.minutes, t2.minutes)
    &lt;?&gt; (compare, t1.seconds, t2.seconds)
end
</code></pre>

<h2 id="Git.-.Commit.Messages">Git - Commit Messages</h2>

<ul>
<li>The subject should express what the commit achieves</li>
<li>The body should provide context for the commit</li>
<li>Subject and body should be clearly separated and working independently</li>
<li>Commit messages must not exceed a line length of 80 characters</li>
<li>Commits should include a signature (<code>git commit -s</code>)</li>
<li>Commit messages can use markdown if it helps clarity</li>
</ul>


<p>Examples:</p>

<ul>
<li>https://github.com/xapi-project/xenopsd/pull/415/commits/fb6da3e9f9d5c1a17ee5ab3a904e5d90306980a4</li>
<li>https://github.com/ocaml/ocaml/commit/63e1460a69758b029c2def42192f80faaac1b7b2</li>
</ul>


<h2 id="Use.Pattern.Matching.for.Value.Destruction">Use Pattern Matching for Value Destruction</h2>

<p>The readability of code is improved by using pattern matching rather
than (neeply nested) if-then-else control flow. Multiple patterns can be
matched at the same time.</p>

<pre><code>type color = Red | Yellow | Green

let wait = function (* good *)
  | Red     -&gt; seconds 30
  | Yellow  -&gt; seconds 10
  | Green   -&gt; seconds 0

let wait color = (* bad *)
  if color = Red then seconds 30
  else if color = Yellow then seconds 10
  else seconds 0
</code></pre>

<h2 id="Avoid.introducing.new.dependencies">Avoid introducing new dependencies</h2>

<p>Introducing new dependencies on outside libraries needs to be well
justified.</p>

<p>With Opam it is easy to install libraries and to use them. It is usually
better to use a well-established and maintained library than to roll
your own. This is especially true for well-established protocols,
formats and problems in general. But any new library also brings along
the responsibility to watch its development.</p>

</body>
</html>
